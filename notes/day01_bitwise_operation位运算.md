如何打印一个十进制数的 32 位表示？

> 实际上，Int 的长度就是 32 位，Long 的长度是 64 位

```java

package day01_bitwise_operation;

public class Test {

    public static void main(String[] args) {
        testFunc(12387149);
    }

    public static void testFunc(int num) {
        for (int i = 31; i >= 0; i--) {
            String result = (num & (1 << i)) == 0 ? "0" : "1";
            System.out.print(result);
        }

    }
}
```

```java
// output
00000000101111010000001101001101
```

以上代码的原理： 分别拿输入值 和 以下值作 与 运算:

```java
10000000000000000000000000000000
01000000000000000000000000000000
00100000000000000000000000000000
00010000000000000000000000000000
....
....
00000000000000000000000000000001
```

判断与运算的结果是否为 0， 分别打印字符 `"0"` 和 `"1"`

`1` 所在的位 和 `1`作与运算，结果为, 因为是和 `1` 的左移结果作运算， 而`1` 的左移结果始终只有某一位为 `1`, 其他位是 `0` 。 这样以来，就可以去判断 输入值 的每一位，仅都为1, 才会打印 1。 从而就能将输入值的 32 位形式打印出来了。



位元算中，正数和负数的表示：

Java 整数是有符号整数，32 位中的首位为符号位， 0 表示正数， 1 表示复数，后31 位用于表示实际的值范围：

正数：

正数的范围是： `0 ~ 2^31 - 1`

负数：

负数的范围是：`-2^31 ~ -1`

其表示的范围就是 `-2^31 ~ 2^31-1`



C 语言中 整数是无符号表示，其值范围就是 `0 ~ 2^32 - 1`, java 中整数是有符号的，所以同等数位一半用于表示正数，一半表示负数。所以有符号的最大值没有无符号的整型最大值大。

> 上面的表示中，为什么要减去1 ？ 
>
> 先看，无符号整型。 `0 ~ 2^32 - 1` 表示了多少个数 ？算上 `0` ，一共表示了 `2^32` 个数。
>
> 有符号整型， `-2^31 ~ 2^31-1` 表示了多少个数？ 也是 `2^32` 个数。
>
> 为什么？， 32 位因为有一个符号位， 所以 31 位最多能表示的状态是 `2^31` 个， 考虑正负， 所以要乘上2倍， 那么 `2^31 * 2` = `2^31 * 2^1` = `2^32`, 注意，32 位全为0，即表示 `0`, 所以，由此也可以发现，正数中有一个状态专门用于表示 `0`, 所以负数所能表示的状态会比正数多一个，什么意思？
>
> `-2^31 ~ 2^31-1`， 即 ： `-2,147,483,648` ~ `2,147,483,647`, 正是因为正数中有一个状态专门用于表示 `0`， 所以正数除去 `0` 能够表示的状态个数就为 `2^31-1`





负数如何表达？ 如果是一个负数，符号位一定是1，    其值，就是后面所有位取反加一

`-1` 的表示

```java
11111111111111111111111111111111
```

除了首位，其他全部取反，然后加1，可以理解为：

```java
-0000000000000000000000000000001
```



系统最小值的32 位表示：

```java
// Integer.MIN_VALUE
10000000000000000000000000000000
```

为什么？

首位是1，

后面全部位取反

```java
-111111111111111111111111111111
```

然后加1，从后面开始加，如果把最后一位称为 1 位置，那么 1 位置 `0->1`, 

```java
-111111111111111111111111111110
```

因为逢2进1， 所以第2 位置上有一个进位1， 加上这个进位1，

```java
-111111111111111111111111111100
// 依次类推
-111111111111111111111111111000
-111111111111111111111111110000
-111111111111111111111111100000
...    
```

依次类推，直到

```java
-000 0000 0000 0000 0000 0000 0000 0000
```

但是最后 31 位置加1 后，会有一个向前进位，一共能够表示 `2^31` 个状态, 

这样，系统把`-0` 表示为最小值，即为 `-2^31`，即 `-2,147,483,648`



> https://waiterxiaoyy.github.io/2020/04/13/%E6%83%AD%E6%84%A7%EF%BC%81%E7%9B%B4%E5%88%B0%E4%BB%8A%E5%A4%A9%E6%89%8D%E7%9C%9F%E6%AD%A3%E6%98%8E%E7%99%BD%E4%B8%BA%E4%BB%80%E4%B9%88int%E5%9E%8B%E7%9A%84%E5%8F%96%E5%80%BC%E8%8C%83%E5%9B%B4%E6%98%AF-2-31-2-31-1/



左移右移：

```java
int a = 1024;
//00000000000000000000010000000000
a >> 1;
//00000000000000000000001000000000
a >>> 1;
//00000000000000000000001000000000
```

`>>` ，叫做带符号右移，右移后，最左边用符号位来补位；`>>>` 叫做不带符号右移，右移后，最左边用 `0` 补齐

```java
int a = -1024;
//11111111111111111111110000000000
a >> 1;
//11111111111111111111111000000000
a >>> 1;
//01111111111111111111111000000000
```



如何求 5 的相反数？

```java
int a = 5;
int b = -a;// -5
// 除此之外，取反加1，也用于表示相反数
int d = ~c + 1
```

```java
package day01_bitwise_operation;

public class Test {

    public static void main(String[] args) {
        int a = -1024;
        testFunc(5);
        System.out.println();
        testFunc(~5+1);

    }

    public static void testFunc(int num) {
        for (int i = 31; i >= 0; i--) {
            String result = (num & (1 << i)) == 0 ? "0" : "1";
            System.out.print(result);
        }

    }
}
```

```java
00000000000000000000000000000101//5
11111111111111111111111111111011//-5
```

为啥？

二进制源码：`00000000000000000000000000000101`

取反`~`：`11111111111111111111111111111010`

加1 `+1`: `11111111111111111111111111111011`

---

翻译： 先取反再加1，

`~`: `00000000000000000000000000000100`

`+1`:`00000000000000000000000000000101`



